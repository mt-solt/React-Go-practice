// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: random.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createRandom = `-- name: CreateRandom :exec
INSERT INTO random (id, random_val, user_id, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5)
`

type CreateRandomParams struct {
	ID        uuid.UUID `json:"id"`
	RandomVal int64     `json:"random_val"`
	UserID    string    `json:"user_id"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) CreateRandom(ctx context.Context, arg CreateRandomParams) error {
	_, err := q.db.ExecContext(ctx, createRandom,
		arg.ID,
		arg.RandomVal,
		arg.UserID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const deleteRandom = `-- name: DeleteRandom :exec
DELETE FROM random
WHERE id = $1
`

func (q *Queries) DeleteRandom(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteRandom, id)
	return err
}

const getAllRandoms = `-- name: GetAllRandoms :many
SELECT id, random_val, user_id, created_at, updated_at
FROM random
ORDER BY id ASC
`

func (q *Queries) GetAllRandoms(ctx context.Context) ([]Random, error) {
	rows, err := q.db.QueryContext(ctx, getAllRandoms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Random{}
	for rows.Next() {
		var i Random
		if err := rows.Scan(
			&i.ID,
			&i.RandomVal,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRandom = `-- name: GetRandom :one
SELECT id, random_val, user_id, created_at, updated_at
FROM random
WHERE id = $1
`

func (q *Queries) GetRandom(ctx context.Context, id uuid.UUID) (Random, error) {
	row := q.db.QueryRowContext(ctx, getRandom, id)
	var i Random
	err := row.Scan(
		&i.ID,
		&i.RandomVal,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRandomsByUser = `-- name: GetRandomsByUser :many
SELECT id, random_val, user_id, created_at, updated_at
FROM random
WHERE user_id = $1
ORDER BY id ASC
`

func (q *Queries) GetRandomsByUser(ctx context.Context, userID string) ([]Random, error) {
	rows, err := q.db.QueryContext(ctx, getRandomsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Random{}
	for rows.Next() {
		var i Random
		if err := rows.Scan(
			&i.ID,
			&i.RandomVal,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRandom = `-- name: UpdateRandom :exec
UPDATE random
SET random_val = $2, updated_at = $3
WHERE id = $1
`

type UpdateRandomParams struct {
	ID        uuid.UUID `json:"id"`
	RandomVal int64     `json:"random_val"`
	UpdatedAt time.Time `json:"updated_at"`
}

func (q *Queries) UpdateRandom(ctx context.Context, arg UpdateRandomParams) error {
	_, err := q.db.ExecContext(ctx, updateRandom, arg.ID, arg.RandomVal, arg.UpdatedAt)
	return err
}
